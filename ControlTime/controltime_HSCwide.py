#!/opt/local/bin/python"""# Written by Jun E. Okumura in 2014.02# contact paco.sci@gmail.com if you have any questions or comments.This calculate "control time", or effective visivility time.Supported templates are:- SN Ia by Eric Hsiao- SN Ia by Peter Nugent- 91bg-like SN Ia by Peter Nugent- 91T-like SN Ia by Peter Nugent- SN Ibc by Peter Nugent- SN IIL by Peter Nugent- SN IIP by Peter Nugent- SN IIn by Peter NugentSupported fileters are:- Subaru/Hyper Suprime-Cam (HSC)## NOTE ##To run this code, those packages below is required.If you don't have them, try to download those packages first.1. numpy (the author used version '1.8.0'; see http://www.numpy.org/)2. scipy (the author used version '0.12.0'; see http://www.scipy.org/)"""import numpy as npfrom scipy import interpolateimport mathimport sys### options ###object_type = 0# 0:SN Ia (Hsiao) 1:SN Ia (Nugent) 2:SN Ia-91bg (Nugent) 3:SN Ia-91T (Nugent)# 4:SN Ibc (Nugent) 5:SN IIL (Nugent) 6:SN IIP (Nugent) 7:SN IIn (Nugent)# Dust models for SN Ia. You can choose Kessler+2009 model (from SDSS-II observation), or # Hatano+1998 model (from simulation; this can be used for extremely dust-affected Ias)# minimal dust is digitized from Kyle+2010 paper.dust_model = 0 # [0: Kessler+2009 model, 1: Hatano+1998 model, 2: minimal dust]# set up parametersif object_type == 0: targetdir = 'Hsiao_Ia'elif object_type == 1: targetdir = 'Nugent_Ia'elif object_type == 2: targetdir = 'Nugent_Ia91bg'elif object_type == 3: targetdir = 'Nugent_Ia91T'elif object_type == 4: targetdir = 'Nugent_Ibc'elif object_type == 5: targetdir = 'Nugent_IIL'elif object_type == 6: targetdir = 'Nugent_IIP'elif object_type == 7: targetdir = 'Nugent_IIn'bands = ['g','r','i','z','y']if dust_model == 0: dust_name = 'K09dust'elif dust_model == 1: dust_name = 'H98dust'else: dust_name = 'minimal_dust'# # flux equivalent with 26.0 mag. This is set to test the condition used in SXDS SN Ia rate study.# flux260 = pow(10,(34.018-26.0)/2.5)# cadence definitioncadence = [1.0, 5.0, 9.0, 13.0, 17.0, 21.0, 25.0, 29.0, 33.0, 37.0, 41.0, 45.0, 49.0, 53.0, 57.0, 61.0, 65.0, 69.0, 73.0, 77.0, 81.0, 85.0, 89.0, 93.0]# limiting magnitude for each epochslim = [26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1, 26.1]fout = open('./CT_SN%s_%s_HSCwide.txt' % (targetdir.split('_')[1], dust_name),'w')for z in np.arange(0.20,1.81,0.05):    print 'calculating control time at z=%.2f' % z    # initialize control time array    # ct_tot is the summation of all detectable date.    # ct_n is the number of light curves.    ct_tot = 0.0    ct_n = 0    Nomax = 100    for No in range(1, Nomax+1):        sys.stdout.write("\rprocessing %d" % No)        sys.stdout.flush()        # open simulated light curves        LC = np.loadtxt('./simulated_LC/HSC/%s/%s/lc_z%03d_No%03d.txt' % (targetdir, dust_name, z*100.1, No))        LCint_r = interpolate.interp1d(LC[:,0],LC[:,2],kind='linear')        ct = 0.0        # iterate for offset [day]        # If you put range(-70,10), the code allow SNe Ia whose the day of max lie in [-10, 70]        for offset in range(-500,500):        #for offset in range(-10,71):            criterion1 = 0 # you can add criterion            for i in range(len(cadence)):                day = cadence[i] + offset                # if day is in LC range, set interpolated magnitude, otherwise set 30.0 mag                rmag = LCint_r(day) if (day<LC[-1,0]) and (day>LC[0,0]) else 30.0                if rmag < 30.0:                    rflux = pow(10,  -0.4*rmag) # convert magnitude to flux                    flim = pow(10, -0.4*lim[i])                    ferr_poisson = flim/5.0 # poisson error                    ferr_systematic = rflux*0.02 # additional systematic error (2%)                    ferr = math.sqrt(ferr_poisson*ferr_poisson+ferr_systematic*ferr_systematic)                    flux = rflux + np.random.normal(0.0,ferr)                    if (flux>ferr*5.0): criterion1+=1                # add +1 to ct if the simulated LC pass the requirements            if (criterion1>=5): ct+=1.0        ct_tot += ct        ct_n += 1    ct_result = ct_tot/ct_n    print '\n%4.2f %6.3f' % (z, ct_result)    fout.write('%4.2f %6.3f\n' % (z, ct_result))fout.close()print 'That\'s all forks!'